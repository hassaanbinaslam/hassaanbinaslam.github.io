<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-04">
<meta name="description" content="I recreate the spiral experiment from the MobileNetV2 paper to visually prove how neural networks can avoid information loss.">

<title>Visualizing MobileNetV2: A Hands-On Guide to Why Linear Bottlenecks Work – Random Thoughts</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../images/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ec1a476101e3788554028e6f9c82f7c1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-D1ST9BH6HX"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-D1ST9BH6HX', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Visualizing MobileNetV2: A Hands-On Guide to Why Linear Bottlenecks Work – Random Thoughts">
<meta property="og:description" content="I recreate the spiral experiment from the MobileNetV2 paper to visually prove how neural networks can avoid information loss.">
<meta property="og:image" content="https://hassaanbinaslam.github.io/posts/images/2025-09-04-mobilenetv2-spiral-experiment.jpeg">
<meta property="og:site_name" content="Random Thoughts">
<meta name="twitter:title" content="Visualizing MobileNetV2: A Hands-On Guide to Why Linear Bottlenecks Work – Random Thoughts">
<meta name="twitter:description" content="I recreate the spiral experiment from the MobileNetV2 paper to visually prove how neural networks can avoid information loss.">
<meta name="twitter:image" content="https://hassaanbinaslam.github.io/posts/images/2025-09-04-mobilenetv2-spiral-experiment.jpeg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Random Thoughts</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/hassaanbinaslam/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/hassaanbinaslam/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/hassaanbinaslam"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#the-experiment-how-to-simulate-a-neural-network-layer" id="toc-the-experiment-how-to-simulate-a-neural-network-layer" class="nav-link" data-scroll-target="#the-experiment-how-to-simulate-a-neural-network-layer">The Experiment: How to Simulate a Neural Network Layer</a>
  <ul class="collapse">
  <li><a href="#step-1-our-manifold-of-interest---the-spiral" id="toc-step-1-our-manifold-of-interest---the-spiral" class="nav-link" data-scroll-target="#step-1-our-manifold-of-interest---the-spiral">Step 1: Our “Manifold of Interest” - The Spiral</a></li>
  <li><a href="#step-2-the-transformation-pipeline" id="toc-step-2-the-transformation-pipeline" class="nav-link" data-scroll-target="#step-2-the-transformation-pipeline">Step 2: The Transformation Pipeline</a></li>
  </ul></li>
  <li><a href="#the-code-bringing-the-theory-to-life-with-python" id="toc-the-code-bringing-the-theory-to-life-with-python" class="nav-link" data-scroll-target="#the-code-bringing-the-theory-to-life-with-python">The Code: Bringing the Theory to Life with Python</a>
  <ul class="collapse">
  <li><a href="#part-1-generating-the-spiral" id="toc-part-1-generating-the-spiral" class="nav-link" data-scroll-target="#part-1-generating-the-spiral">Part 1: Generating the Spiral</a></li>
  <li><a href="#part-2-the-transformation-function" id="toc-part-2-the-transformation-function" class="nav-link" data-scroll-target="#part-2-the-transformation-function">Part 2: The Transformation Function</a></li>
  <li><a href="#part-3-running-the-show-and-plotting-the-results" id="toc-part-3-running-the-show-and-plotting-the-results" class="nav-link" data-scroll-target="#part-3-running-the-show-and-plotting-the-results">Part 3: Running the Show and Plotting the Results</a></li>
  </ul></li>
  <li><a href="#the-moment-of-truth-analyzing-our-results" id="toc-the-moment-of-truth-analyzing-our-results" class="nav-link" data-scroll-target="#the-moment-of-truth-analyzing-our-results">The Moment of Truth: Analyzing Our Results</a>
  <ul class="collapse">
  <li><a href="#the-catastrophe-the-low-dimension-case-dim2-dim3-dim5" id="toc-the-catastrophe-the-low-dimension-case-dim2-dim3-dim5" class="nav-link" data-scroll-target="#the-catastrophe-the-low-dimension-case-dim2-dim3-dim5">The Catastrophe: The Low-Dimension Case (<code>dim=2</code>, <code>dim=3</code>, <code>dim=5</code>)</a></li>
  <li><a href="#the-redemption-the-high-dimension-case-dim15-dim30-dim100" id="toc-the-redemption-the-high-dimension-case-dim15-dim30-dim100" class="nav-link" data-scroll-target="#the-redemption-the-high-dimension-case-dim15-dim30-dim100">The Redemption: The High-Dimension Case (<code>dim=15</code>, <code>dim=30</code>, <code>dim=100</code>)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Visualizing MobileNetV2: A Hands-On Guide to Why Linear Bottlenecks Work</h1>
  <div class="quarto-categories">
    <div class="quarto-category">papers</div>
  </div>
  </div>

<div>
  <div class="description">
    I recreate the spiral experiment from the MobileNetV2 paper to visually prove how neural networks can avoid information loss.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 4, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><img src="images/2025-09-04-mobilenetv2-spiral-experiment.jpeg" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>I was recently re-reading a paper that I consider a classic in the world of efficient AI: Google’s <a href="https://arxiv.org/abs/1801.04381"><strong>“MobileNetV2: Inverted Residuals and Linear Bottlenecks.”</strong></a> It’s a cornerstone of modern computer vision, and its ideas power countless applications running on our phones every day.</p>
<p>As I was going through its theoretical section, I was struck again by a fascinating and somewhat puzzling claim. The authors argue that a fundamental building block of virtually all modern neural networks, the ReLU activation function, can be surprisingly destructive. It can take the rich, structured information a network has learned and literally wipe parts of it out of existence.</p>
<p>But then they proposed a clever trick to prevent this. They claimed that if you first take your data and project it into a <em>much higher-dimensional space</em>, you create a kind of “safety net.” In this expanded space, ReLU can perform its magic without causing catastrophic damage.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/2025-09-04-mobilenetv2-spiral-experiment/paper-figure-1.PNG" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Experiment results from the original paper"><img src="images/2025-09-04-mobilenetv2-spiral-experiment/paper-figure-1.PNG" class="img-fluid figure-img" alt="Experiment results from the original paper"></a></p>
<figcaption>Experiment results from the original paper</figcaption>
</figure>
</div>
<p>This sounded incredibly cool, but also very abstract. What does it even mean to project a spiral into a 30-dimensional space? Can you actually <em>see</em> this “information destruction” and subsequent “information preservation” happen?</p>
<p>I decided to put it to the test. In this post, we’re going to recreate the paper’s beautiful spiral experiment from scratch.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Get the code">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Get the code
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>All the code can be found in the GitHub repository : <a href="https://github.com/hassaanbinaslam/hassaanbinaslam.github.io/tree/main/posts/2025-09-04-mobilenetv2-spiral-experiment.ipynb">2025-09-04-mobilenetv2-spiral-experiment.ipynb</a>.</p>
</div>
</div>
</div>
</section>
<section id="the-experiment-how-to-simulate-a-neural-network-layer" class="level2">
<h2 class="anchored" data-anchor-id="the-experiment-how-to-simulate-a-neural-network-layer">The Experiment: How to Simulate a Neural Network Layer</h2>
<p>Before we jump into the code, let’s lay out our game plan. We’re trying to simulate the journey of a feature map, what the paper calls a “manifold of interest”, as it passes through a single, simplified neural network layer. Our simulation will have three key stages that directly mirror the paper’s theory.</p>
<section id="step-1-our-manifold-of-interest---the-spiral" class="level3">
<h3 class="anchored" data-anchor-id="step-1-our-manifold-of-interest---the-spiral">Step 1: Our “Manifold of Interest” - The Spiral</h3>
<p>First, we need some data. In a real network, the “manifold of interest” is a complex, high-dimensional shape representing learned features like edges, textures, or even parts of a face. That’s a bit hard to draw.</p>
<p>Instead, we’ll use a simple 2D spiral as a stand-in. It’s a perfect choice because it has a clear, recognizable structure. If any part of our transformation process damages the spiral, we’ll be able to see it instantly.</p>
</section>
<section id="step-2-the-transformation-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="step-2-the-transformation-pipeline">Step 2: The Transformation Pipeline</h3>
<p>Next, we’ll pass our spiral through a three-step pipeline designed to mimic the MobileNetV2 block:</p>
<ol type="1">
<li><p><strong>Expand (Project Up):</strong> We’ll take our 2D spiral and project it into a higher, <code>n</code>-dimensional space. This <code>n</code> is the key variable we’ll be changing. We’ll test small values (like <code>n=2</code> or <code>n=3</code>) and large values (like <code>n=15</code> or <code>n=30</code>). This step simulates the “expansion” layer of the network.</p></li>
<li><p><strong>Apply Non-linearity (The Dangerous Part):</strong> While the data is living in this high-dimensional space, we’ll apply the <code>ReLU</code> function to it. This is the moment of truth. According to the theory, this step is potentially destructive.</p></li>
<li><p><strong>Project Back (Observe the Result):</strong> We can’t see what’s happening in 30 dimensions, so to check on our spiral, we need to bring it back home. We’ll project the data from the <code>n</code>-dimensional space back down to 2D so we can plot it and see what happened.</p></li>
</ol>
<p>By comparing the final plot to our original input spiral, we can visually determine whether the information was preserved or destroyed.</p>
</section>
</section>
<section id="the-code-bringing-the-theory-to-life-with-python" class="level2">
<h2 class="anchored" data-anchor-id="the-code-bringing-the-theory-to-life-with-python">The Code: Bringing the Theory to Life with Python</h2>
<p>Alright, let’s translate our experiment into code. We’ll be using two of the most common libraries in data science: <code>numpy</code> for the heavy lifting with matrix math, and <code>matplotlib</code> to visualize our results.</p>
<section id="part-1-generating-the-spiral" class="level3">
<h3 class="anchored" data-anchor-id="part-1-generating-the-spiral">Part 1: Generating the Spiral</h3>
<p>First, we need a function to create our hero — the 2D spiral. We can do this easily using some basic trigonometry. This function generates a set of (x, y) coordinates that trace out a nice, clean spiral.</p>
<div id="69f46e07" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">def</span> generate_spiral(num_points<span class="op">=</span><span class="dv">1000</span>, revolutions<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="co">"""</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">    Generates a 2D spiral dataset using polar coordinates.</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">    """</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="co"># STEP 1: Define the ANGLE (theta)</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="co"># We want to sweep around a circle multiple times. A full circle is 2*pi radians.</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="co"># To go around, say, 3 times, we need our angle to go from 0 to 3 * 2 * pi.</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="co"># np.linspace gives us an array of evenly spaced numbers in that range.</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="co"># So, `theta` is now an array of 1000 angles, from 0 up to our max angle.</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    theta <span class="op">=</span> np.linspace(<span class="dv">0</span>, revolutions <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> np.pi, num_points)</span>
<span id="cb1-13"><a href="#cb1-13"></a>    </span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="co"># STEP 2: Define the RADIUS (r)</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="co"># For a circle, the radius is constant. For a spiral, we want the radius</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="co"># to grow as the angle gets bigger. The simplest way to do this is to just</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="co"># set the radius equal to the angle! As `theta` increases, `radius` increases too.</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    radius <span class="op">=</span> theta</span>
<span id="cb1-19"><a href="#cb1-19"></a>    </span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="co"># STEP 3: Convert from Polar to Cartesian Coordinates</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="co"># We now have 1000 points defined by their polar coordinates (radius, theta).</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="co"># To plot them on a standard graph, we need to convert them to (x, y) coordinates.</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="co"># The standard conversion formulas are:</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="co"># x = r * cos(theta)</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="co"># y = r * sin(theta)</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="co"># Since `radius` and `theta` are numpy arrays, this calculation happens for</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>    <span class="co"># all 1000 points at once in an efficient, "vectorized" way.</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>    x <span class="op">=</span> radius <span class="op">*</span> np.cos(theta)</span>
<span id="cb1-29"><a href="#cb1-29"></a>    y <span class="op">=</span> radius <span class="op">*</span> np.sin(theta)</span>
<span id="cb1-30"><a href="#cb1-30"></a>    </span>
<span id="cb1-31"><a href="#cb1-31"></a>    <span class="co"># STEP 4: Combine into a single array</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="co"># We now have two separate arrays, `x` and `y`, each with 1000 numbers.</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>    <span class="co"># We want to combine them into a single structure for easier handling.</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    <span class="co"># np.vstack stacks them vertically into a (2, 1000) array.</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    <span class="co"># The .T (transpose) operation flips this to a (1000, 2) array.</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    <span class="co"># Now, each row of our final array is a single (x, y) point on the spiral.</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    spiral_data <span class="op">=</span> np.vstack((x, y)).T</span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="cf">return</span> spiral_data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Running just the <code>generate_spiral</code> function and plotting its output gives us our beautiful starting manifold. This is the “perfect” information we are trying to preserve. It’s the benchmark against which we’ll measure the success or failure of our transformation.</p>
<div id="7f8ec6d1" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co"># Generate the spiral</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>input_spiral <span class="op">=</span> generate_spiral()</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co"># Plot it</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">4</span>))</span>
<span id="cb2-9"><a href="#cb2-9"></a>plt.plot(input_spiral[:, <span class="dv">0</span>], input_spiral[:, <span class="dv">1</span>])</span>
<span id="cb2-10"><a href="#cb2-10"></a>plt.title(<span class="st">"Our Input 'Manifold of Interest'"</span>)</span>
<span id="cb2-11"><a href="#cb2-11"></a>plt.gca().set_aspect(<span class="st">'equal'</span>, <span class="st">'box'</span>)</span>
<span id="cb2-12"><a href="#cb2-12"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="2025-09-04-mobilenetv2-spiral-experiment_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Our entire goal is to see if it survives the journey through our simulated network layer. Now, let’s build the pipeline that will put it to the test.</p>
</section>
<section id="part-2-the-transformation-function" class="level3">
<h3 class="anchored" data-anchor-id="part-2-the-transformation-function">Part 2: The Transformation Function</h3>
<p>This next function is the core of our entire experiment. It takes our 2D spiral, sends it on its journey through high-dimensional space, and brings it back.</p>
<p>I’ll show you the final, working code first, and then I’ll confess a little bug I ran into along the way. It’s a great example of the kind of thing you run into when working with linear algebra.</p>
<div id="6b4a06b9" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> transform_manifold(data_2d, n_dim):</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">    Projects 2D data to n_dim, applies ReLU, and projects back.</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">    """</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co"># Let's trace the shapes with data_2d.shape = (1000, 2) and n_dim = 15</span></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="co"># --- STEP 1: Create the "Expansion" Matrix ---</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="co"># We need a matrix that can transform a 2D vector into a 15D vector.</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="co"># To do this, it must have a shape of (2, 15).</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="co"># np.random.randn fills this matrix with random numbers from a</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="co"># standard normal distribution. This simulates the random initial</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="co"># weights of a new neural network layer.</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    T_forward <span class="op">=</span> np.random.randn(<span class="dv">2</span>, n_dim)</span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="co"># T_forward.shape is (2, 15)</span></span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="co"># --- STEP 2: Project Up to High-Dimensional Space ---</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>    <span class="co"># This is the "Expand" operation. We use the matrix multiplication</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="co"># operator (@) to apply the transformation.</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="co"># The shapes must be compatible: (1000, 2) @ (2, 15) -&gt; (1000, 15)</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="co"># The inner dimensions (2 and 2) match, which is perfect.</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>    <span class="co"># The result, `projected_data`, is our spiral, but now each of its</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="co"># 1000 points is represented by 15 numbers instead of 2.</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>    projected_data <span class="op">=</span> data_2d <span class="op">@</span> T_forward</span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="co"># projected_data.shape is (1000, 15)</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>    </span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="co"># --- STEP 3: Apply the ReLU Non-Linearity ---</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>    <span class="co"># `np.maximum(0, array)` is the numpy equivalent of the ReLU function.</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>    <span class="co"># It scans through every single number in our (1000, 15) matrix and</span></span>
<span id="cb3-29"><a href="#cb3-29"></a>    <span class="co"># replaces any negative number with a zero.</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>    <span class="co"># This is the critical, information-destroying step.</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>    relu_data <span class="op">=</span> np.maximum(<span class="dv">0</span>, projected_data)</span>
<span id="cb3-32"><a href="#cb3-32"></a>    <span class="co"># relu_data.shape is still (1000, 15)</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>    </span>
<span id="cb3-34"><a href="#cb3-34"></a>    <span class="co"># --- STEP 4: Create the "Projection Back" Matrix ---</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>    <span class="co"># Now we need to get back to 2D so we can see what happened.</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>    <span class="co"># We can't use a true inverse because our `T_forward` matrix isn't square.</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>    <span class="co"># The next best thing is the pseudo-inverse. `np.linalg.pinv` calculates</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>    <span class="co"># the best possible "reverse" transformation matrix.</span></span>
<span id="cb3-39"><a href="#cb3-39"></a>    <span class="co"># The pseudo-inverse of a (2, 15) matrix will have the shape (15, 2).</span></span>
<span id="cb3-40"><a href="#cb3-40"></a>    T_backward <span class="op">=</span> np.linalg.pinv(T_forward)</span>
<span id="cb3-41"><a href="#cb3-41"></a>    <span class="co"># T_backward.shape is (15, 2)</span></span>
<span id="cb3-42"><a href="#cb3-42"></a></span>
<span id="cb3-43"><a href="#cb3-43"></a>    <span class="co"># --- STEP 5: Project Back Down to 2D ---</span></span>
<span id="cb3-44"><a href="#cb3-44"></a>    <span class="co"># We apply the backward transformation to our ReLU-ed data.</span></span>
<span id="cb3-45"><a href="#cb3-45"></a>    <span class="co"># Again, let's check the shapes: (1000, 15) @ (15, 2) -&gt; (1000, 2)</span></span>
<span id="cb3-46"><a href="#cb3-46"></a>    <span class="co"># The inner dimensions (15 and 15) match perfectly.</span></span>
<span id="cb3-47"><a href="#cb3-47"></a>    <span class="co"># The result, `reconstructed_data`, is our final spiral, ready to be plotted.</span></span>
<span id="cb3-48"><a href="#cb3-48"></a>    reconstructed_data <span class="op">=</span> relu_data <span class="op">@</span> T_backward</span>
<span id="cb3-49"><a href="#cb3-49"></a>    <span class="co"># reconstructed_data.shape is (1000, 2)</span></span>
<span id="cb3-50"><a href="#cb3-50"></a>    </span>
<span id="cb3-51"><a href="#cb3-51"></a>    <span class="cf">return</span> reconstructed_data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="part-3-running-the-show-and-plotting-the-results" class="level3">
<h3 class="anchored" data-anchor-id="part-3-running-the-show-and-plotting-the-results">Part 3: Running the Show and Plotting the Results</h3>
<p>Finally, we just need to loop through the different dimensions we want to test (<code>2, 3, 5, 15, 30</code>), call our transformation function for each one, and use <code>matplotlib</code> to plot the results in a neat row.</p>
<div id="78b320bb" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"># Dimensions to test</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>dims_to_test <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">30</span>, <span class="dv">100</span>]</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co"># Create a figure to hold all our plots</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="bu">len</span>(dims_to_test) <span class="op">+</span> <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">3</span>))</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co"># Plot the original input spiral</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>]</span>
<span id="cb4-11"><a href="#cb4-11"></a>ax.plot(input_spiral[:, <span class="dv">0</span>], input_spiral[:, <span class="dv">1</span>])</span>
<span id="cb4-12"><a href="#cb4-12"></a>ax.set_title(<span class="st">"Input"</span>)</span>
<span id="cb4-13"><a href="#cb4-13"></a>ax.set_aspect(<span class="st">'equal'</span>, <span class="st">'box'</span>)</span>
<span id="cb4-14"><a href="#cb4-14"></a>ax.axis(<span class="st">'off'</span>)</span>
<span id="cb4-15"><a href="#cb4-15"></a></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co"># Loop through the dimensions, transform, and plot</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="cf">for</span> i, n <span class="kw">in</span> <span class="bu">enumerate</span>(dims_to_test):</span>
<span id="cb4-18"><a href="#cb4-18"></a>    reconstructed_spiral <span class="op">=</span> transform_manifold(input_spiral, n)</span>
<span id="cb4-19"><a href="#cb4-19"></a>    </span>
<span id="cb4-20"><a href="#cb4-20"></a>    ax <span class="op">=</span> axes[i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb4-21"><a href="#cb4-21"></a>    ax.plot(reconstructed_spiral[:, <span class="dv">0</span>], reconstructed_spiral[:, <span class="dv">1</span>])</span>
<span id="cb4-22"><a href="#cb4-22"></a>    ax.set_title(<span class="ss">f"Output/dim=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-23"><a href="#cb4-23"></a>    ax.set_aspect(<span class="st">'equal'</span>, <span class="st">'box'</span>)</span>
<span id="cb4-24"><a href="#cb4-24"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb4-25"><a href="#cb4-25"></a>    </span>
<span id="cb4-26"><a href="#cb4-26"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="2025-09-04-mobilenetv2-spiral-experiment_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="the-moment-of-truth-analyzing-our-results" class="level2">
<h2 class="anchored" data-anchor-id="the-moment-of-truth-analyzing-our-results">The Moment of Truth: Analyzing Our Results</h2>
<p>Let’s break down what we’re seeing here, moving from left to right.</p>
<section id="the-catastrophe-the-low-dimension-case-dim2-dim3-dim5" class="level3">
<h3 class="anchored" data-anchor-id="the-catastrophe-the-low-dimension-case-dim2-dim3-dim5">The Catastrophe: The Low-Dimension Case (<code>dim=2</code>, <code>dim=3</code>, <code>dim=5</code>)</h3>
<p>First, look at the two plots immediately following the input. When we projected our 2D spiral into an equally low-dimensional space (2D or 3D) and applied <code>ReLU</code>, the result is a disaster.</p>
<p>The beautiful, continuous spiral is completely mangled.</p>
<p>This is exactly what the paper means by <strong>catastrophic information loss</strong>. The <code>ReLU</code> function, confined to a low-dimensional space, had no choice but to destroy large chunks of our manifold. You could never hope to reconstruct the original spiral from this wreckage.</p>
</section>
<section id="the-redemption-the-high-dimension-case-dim15-dim30-dim100" class="level3">
<h3 class="anchored" data-anchor-id="the-redemption-the-high-dimension-case-dim15-dim30-dim100">The Redemption: The High-Dimension Case (<code>dim=15</code>, <code>dim=30</code>, <code>dim=100</code>)</h3>
<p>When we projected our spiral into a high-dimensional space (<code>dim=15</code>, <code>dim=30</code>, and especially <code>dim=100</code>) before applying <code>ReLU</code>, the structure of the spiral survived the round trip almost perfectly intact. All the loops are there, the spacing is correct, and the overall shape is instantly recognizable.</p>
<p>This is the <strong>“high-dimensional safety net”</strong> in action. By giving the manifold plenty of extra dimensions to exist in, we allowed <code>ReLU</code> to perform its non-linear transformation without destroying the essential information. Even if <code>ReLU</code> zeroed out a few of the dimensions, the core structure of the spiral was preserved in the many dimensions that remained.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/hassaanbinaslam\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="hassaanbinaslam/myblog_utterances" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>